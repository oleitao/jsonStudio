IDEAS FOR AN IDE FOCUSED ON JSON FILES (.txt)

=== Editor Core ===

* [ ] Formatting and linting: configurable prettifier, duplicate key detection, trailing commas; support JSON, JSONC, and JSON5.
* [ ] Schema-based validation: real-time validation via JSON Schema (recent drafts), hover to see errors, quick-fixes, automatic $ref resolution (local/remote).
* [ ] Synchronized multiple views: Text ↔ Tree (collapsible) ↔ Table (for arrays of objects) ↔ Side-by-side diff.
* [ ] Search & transform: JSONPath support and jq integration with live preview.
* [ ] Smart diff/merge: semantic “by key” comparison (not line-based), 3-way merge, moved-node detection.
* [ ] Large file handling: incremental/streaming parsing, partial loading, and virtual scrolling.
* [ ] Autocomplete: schema-based suggestions, snippets, and automatic generation of valid objects.
* [ ] Per-node history: undo/redo scoped to the modified branch.

=== Quality of Life ===

* [ ] Secret/PII detection: highlighting, redaction, and warnings for keys like apiKey/password.
* [ ] Templates & boilerplates: create from schema; catalog (OpenAPI, package.json, tsconfig…).
* [ ] Refactors: rename key globally, extract subtree into $ref, sort keys with rules.
* [ ] Cross-validation: custom rules (e.g., “if type=A then fields must contain X”).
* [ ] Comments: support JSONC/JSON5 and preserve comments on format.
* [ ] Quick actions: duplicate node, move ↑↓, wrap in object/array, convert types (string⇄number⇄boolean).

=== Visualization & Debugging ===

* [ ] Statistics: counts, sizes, type distribution, most frequent keys.
* [ ] Quick charts: bar/pie from arrays of objects (e.g., status by count).
* [ ] Heatmap: highlight nodes recently changed or with errors.
* [ ] Reference explorer: navigate $id/$ref, “peek definition”.

=== Integrations with APIs & Dev Tools ===

* [ ] Mock server: local server that responds according to a JSON/Schema (configurable latency and error rates).
* [ ] Contract tests: compare payloads against schemas (OpenAPI/AsyncAPI/Avro) and generate reports.
* [ ] Built-in CLI: run jq, ajv, yq (for YAML⇄JSON), with “copy as command”.
* [ ] Integrated Git: per-node blame, inline diff, pre-commit hooks (lint/validate).
* [ ] Connectors: S3/GCS, remote URLs, workspaces with auto refresh.

=== Advanced Experiments ===

* [ ] Schema inference: generate JSON Schema from multiple examples (tolerant to variations).
* [ ] Transformation assistant: “explain/generate a jq to transform A→B” (possible AI use).
* [ ] Security validation: size limits, banned keys, PII detector.
* [ ] Localization: key maps for i18n (detect untranslated keys across files).

=== UX/UI ===

* [ ] Global command (⌘K): actions, keys, paths, schemas.
* [ ] Breadcrumbs: show $.orders[12].items[3].price with click-to-jump.
* [ ] Pins: pin favorite nodes at the top.
* [ ] Quick inspection: hover shows samples and metadata (size in bytes, depth).
* [ ] Themes & accessibility: high contrast, configurable mono fonts, RTL-ready.

=== Suggested Architecture ===

* [ ] Desktop (cross-platform): Electron or Tauri + Monaco Editor; validation with ajv; workers for parsing; Rust (Serde/Simdjson) via Tauri for huge files.
* [ ] Web: React + Monaco, ajv + json-source-map (map position→node), Web Workers to keep the UI non-blocking.
* [ ] Optional backend: Node/Rust for heavy comparisons, schema storage, and audits.

=== Sample Roadmap ===

1. MVP (2–3 weeks): Monaco editor, formatting, tree view, AJV validation, open/save, basic JSONPath.
2. Pro version: per-node diff/merge, integrated jq, schema-based autocomplete, templates, Git.
3. Team version: mock server, contract tests, remote connectors, security policies, real-time collaboration (CRDTs).

=== Extras to Shine ===

* [ ] “Explain this error”: translate validation messages into natural language and suggest fixes.
* [ ] Fake data generator: from the schema (faker/json-schema-faker) for testing.
* [ ] Quick “/” commands: /sort keys, /flatten, /dedupe, /to csv.
* [ ] Exports: CSV (with column selection), YAML, NDJSON, Parquet (via wasm/arrow).
